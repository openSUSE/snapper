/* ------------------------------------------------------------------------------
 * Copyright (c) 2006-2012 Novell, Inc. All Rights Reserved.
 *
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of version 2 of the GNU General Public License as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, contact Novell, Inc.
 *
 * To contact Novell about this file by physical or electronic mail, you may find
 * current contact information at www.novell.com.
 * ------------------------------------------------------------------------------
 */

/**
 * File:	include/snapper/dialogs.ycp
 * Package:	Configuration of snapper
 * Summary:	Dialogs definitions
 * Authors:	Jiri Suchomel <jsuchome@suse.cz>
 *
 * $Id$
 */

{

textdomain "snapper";

import "Confirm";
import "FileUtils";
import "Label";
import "Popup";
import "Wizard";
import "Snapper";
import "String";

include "snapper/helps.ycp";

boolean ReallyAbort() {
    return Popup::ReallyAbort(true);
}

/**
 * Read settings dialog
 * @return `abort if aborted and `next otherwise
 */
symbol ReadDialog() {

    if (! Confirm::MustBeRoot ())
	return `abort;

    Wizard::RestoreHelp(HELPS["read"]:"");
    boolean ret = Snapper::Read();
    return ret ? `next : `abort;
}

/**
 * convert map of userdata to string
 * $[ "a" : "b", "1" : "2" ] -> "a=b,1=2"
 */
string userdata2string (map<string,string> userdata) {

  return mergestring (
    maplist (string key, string val, userdata, {
      return sformat ("%1=%2", key, val);
    }),
    ","
  );
}

// transform userdata from widget to map
map get_userdata (string id) {

    map u               = $[];
    string user_s       = (string) UI::QueryWidget (`id (id), `Value);
    foreach (string line, splitstring (user_s, ","), {
      list<string> split  = splitstring (line, "=");
      if (size (split) > 1)
      {
        u[split[0]:""]   = split[1]:"";
      }
    });
    return u;
}

// generate list of items for Cleanup combo box
list<term> cleanup_items (string current) {

    return maplist (string cleanup, [ "timeline", "number", "" ], {
      return `item (`id (cleanup), cleanup, cleanup == current);
    });
}

// compare editable parts of snapshot maps
boolean snapshot_modified (map orig, map new) {

  boolean ret   = false;
  foreach (string key, any value, (map<string,any>) new, {
    ret = ret || (orig[key]:nil != value);
  });
  return ret;
}

/**
 * Popup for modification of existing snapshot
 * @return true if new snapshot was created
 */
boolean ModifySnapshotPopup (map snapshot) {

    boolean modified            = false;
    integer num                 = snapshot["num"]:0;
    integer previous_num        = snapshot["pre_num"]:num;
    symbol type                 = snapshot["type"]:`none;

    integer pre_index           = Snapper::id2index[previous_num]:0;
    map pre_snapshot            = Snapper::snapshots[pre_index]:$[];

    term snapshot_term (string prefix, map data) {
      return `HBox (`HSpacing (), `Frame ("", `HBox (`HSpacing (0.4), `VBox (
        // text entry label
        `TextEntry (`id (prefix + "description"), _("Description"),
          data["description"]:""),
        // text entry label
        `TextEntry (`id (prefix + "userdata"), _("User data"),
          userdata2string (data["userdata"]:$[])),
        `Left (`ComboBox (`id (prefix + "cleanup"), `opt (`editable, `hstretch),
          // combo box label
          _("Cleanup algorithm"), cleanup_items (data["cleanup"]:""))
        )
      ), `HSpacing (0.4))), `HSpacing ());
    }

    term cont   = `VBox (
      // popup label, %1 is number
      `Label (sformat (_("Modify Snapshot %1"), num)),
      snapshot_term ("", snapshot)
    );

    if (type == `POST)
    {
      cont   = `VBox (
        // popup label, %1, %2 are numbers (range)
        `Label (sformat (_("Modify Snapshots %1 - %2"), previous_num, num)),
        // label
        `Left (`Label (sformat (_("Pre (%1)"), previous_num))),
        snapshot_term ("pre_", pre_snapshot),
        `VSpacing (),
        // label
        `Left (`Label (sformat (_("Post (%1)"), num))),
        snapshot_term ("", snapshot)
      );
    }

    UI::OpenDialog (`opt (`decorated), `HBox (`HSpacing (1), `VBox(
      `VSpacing (0.5),
      `HSpacing (65),
      cont,
      `VSpacing (0.5),
      `ButtonBox (
          `PushButton (`id(`ok), Label::OKButton()),
          `PushButton (`id(`cancel), Label::CancelButton())
      ),
      `VSpacing (0.5)), `HSpacing (1))
    );

    any ret     = nil;
    map args    = $[];
    map pre_args= $[];

    while (true)
    {
        ret     = UI::UserInput ();
        args    = $[
          "num"         : num,
          "description" : UI::QueryWidget (`id ("description"), `Value),
          "cleanup"     : UI::QueryWidget (`id ("cleanup"), `Value),
          "userdata"    : get_userdata ("userdata")
        ];
        if (type == `POST)
        {
          pre_args    = $[
            "num"               : previous_num,
            "description"       : UI::QueryWidget (`id ("pre_description"), `Value),
            "cleanup"           : UI::QueryWidget (`id ("pre_cleanup"), `Value),
            "userdata"          : get_userdata ("pre_userdata")
          ];
        }
        if (ret == `ok || ret == `cancel)
        {
            break;
        }
    }
    UI::CloseDialog ();
    if (ret == `ok)
    {
        if (snapshot_modified (snapshot, args))
        {
          modified      = Snapper::ModifySnapshot (args);
        }
        if (type == `POST && snapshot_modified (pre_snapshot, pre_args))
        {
          modified      = Snapper::ModifySnapshot (pre_args) || modified;
        }
    }

    return modified;
}

/**
 * Popup for creating new snapshot
 * @return true if new snapshot was created
 */
boolean CreateSnapshotPopup (list<integer> pre_snapshots) {

    boolean created     = false;
    list pre_items      = maplist (integer s, pre_snapshots, {
        return `item (`id (s), tostring (s));
    });

    UI::OpenDialog (`opt (`decorated), `HBox (`HSpacing (1), `VBox(
      `VSpacing (0.5),
      `HSpacing (65),
      // popup label
      `Label (_("Create New Snapshot")),
      // text entry label
      `TextEntry (`id ("description"), _("Description"), ""),
      `RadioButtonGroup (`id(`rb_type), `Left (`HVSquash (`VBox (
          `Left (`RadioButton (`id ("single"), `opt (`notify),
              // radio button label
              _("Single snapshot"), true)),
          `Left (`RadioButton (`id ("pre"), `opt (`notify),
              // radio button label
              _("Pre"), false)),
          `VBox (
              `Left (`RadioButton (`id ("post"), `opt (`notify),
                  // radio button label, snapshot selection will follow
                  _("Post, paired with:"), false)
              ),
              `HBox (
                  `HSpacing (2),
                  `Left (`ComboBox (`id (`pre_list), `opt (`notify), "", pre_items))
              )
          )
      )))),
      // text entry label
      `TextEntry (`id ("userdata"), _("User data"), ""),
      // text entry label
      `ComboBox (`id ("cleanup"), `opt (`editable, `hstretch), _("Cleanup algorithm"),
        cleanup_items ("")),
      `VSpacing (0.5),
      `ButtonBox (
          `PushButton (`id(`ok), Label::OKButton()),
          `PushButton (`id(`cancel), Label::CancelButton())
      ),
      `VSpacing (0.5)), `HSpacing (1))
    );

    UI::ChangeWidget (`id ("post"), `Enabled, size (pre_items) > 0);
    UI::ChangeWidget (`id (`pre_list), `Enabled, size (pre_items) > 0);

    any ret     = nil;
    map args    = $[];
    while (true)
    {
        ret     = UI::UserInput ();
        args    = $[
          "type"        : UI::QueryWidget (`id (`rb_type), `Value),
          "description" : UI::QueryWidget (`id ("description"), `Value),
          "pre"         : UI::QueryWidget (`id (`pre_list), `Value),
          "cleanup"     : UI::QueryWidget (`id ("cleanup"), `Value),
          "userdata"    : get_userdata ("userdata")
        ];
        if (ret == `ok || ret == `cancel)
        {
            break;
        }
    }
    UI::CloseDialog ();
    if (ret == `ok)
    {
        created = Snapper::CreateSnapshot (args);
    }
    return created;
}

/**
 * Popup for deleting existing snapshot
 * @return true if snapshot was deleted
 */
boolean DeleteSnapshotPopup (map snapshot) {

    boolean deleted     = false;
    // yes/no popup question
    if (Popup::YesNo (sformat (_("Really delete snapshot '%1'?"), snapshot["num"]:0)) == false)
    {
      return false;
    }
    return Snapper::DeleteSnapshot (snapshot);
}

/**
 * Summary dialog
 * @return dialog result
 */
any SummaryDialog() {

    /* summary dialog caption */
    string caption = _("Snapshots");

    list<map> snapshots		= Snapper::snapshots;
    list<string> configs	= Snapper::configs;

    list snapshot_items	= [];
    // lonely pre snapshots
    list<integer> pre_snapshots = [];

    // generate list of snapshot table items
    list get_snapshot_items () {

      integer i	= -1;
      snapshot_items	= [];
      pre_snapshots     = [];

      foreach (map s, snapshots, {
        i               = i + 1;

        integer num     = s["num"]:0;
        string date     = "";
        if (num != 0)
          date = timestring ("%c", s["date"]:0, false);

        string userdata = userdata2string (s["userdata"]:$[]);

        if (s["type"]:`none == `SINGLE)
        {
          snapshot_items        = add (snapshot_items,
	    `item (`id (i), num, _("Single"), date, "", s["description"]:"", userdata));
        }
        else if (s["type"]:`none == `POST)
        {
          integer pre           = s["pre_num"]:0; // pre canot be 0
          integer index	= Snapper::id2index[pre]:-1;
          if (pre == 0 || index == -1)
          {
            y2warning ("something wrong - pre:%1, index:%2", pre, index);
            continue;
	  }
          string desc           = Snapper::snapshots[index,"description"]:"";
          string pre_date       = timestring ("%c", Snapper::snapshots[index,"date"]:0, false);
          snapshot_items        = add (snapshot_items,
            `item (`id (i), sformat ("%1 - %2", pre, num), _("Pre & Post"), pre_date, date, desc, userdata));
        }
        else
        {
          integer post          = s["post_num"]:0; // 0 means there's no post
          if (post == 0)
          {
            y2milestone ("pre snappshot %1 does not have post", num);
            snapshot_items      = add (snapshot_items,
              `item (`id (i), num, _("Pre"), date, "", s["description"]:"", userdata));
            pre_snapshots         = add (pre_snapshots, num);
          }
          else
          {
            y2milestone ("skipping pre snapshot: %1", num);
          }
        }
      });
      return snapshot_items;
    }

    // update list of snapshots
    void update_snapshots () {

        // busy popup message
        Popup::ShowFeedback ("", _("Reading list of snapshots..."));

        Snapper::InitializeSnapper (Snapper::current_config);
        Snapper::ReadSnapshots ();
        snapshots       = Snapper::snapshots;
        Popup::ClearFeedback ();

        UI::ChangeWidget (`id (`snapshots_table), `Items, get_snapshot_items ());
    }


    term contents = `VBox (
        `HBox (
            // combo box label
            `Label (_("Current Configuration")),
            `ComboBox (`id (`configs), `opt (`notify), "", maplist (string config, configs, {
              return `item (`id (config), config, config == Snapper::current_config);
            })),
            `HStretch ()
        ),
        `Table (`id (`snapshots_table), `opt(`notify, `keepSorting), `header (
            // table header
            _("ID"), _("Type"), _("Start Date"), _("End Date"), _("Description"), _("User Data")),
            get_snapshot_items ()
        ),
        `HBox (
            // button label
            `PushButton (`id (`show), `opt (`default), _("Show Changes")),
            `PushButton (`id (`create), Label::CreateButton ()),
            // button label
            `PushButton (`id (`modify), _("Modify")),
            `PushButton (`id (`delete), Label::DeleteButton ()),
            `HStretch ()
        )
    );

    Wizard::SetContentsButtons(caption, contents, HELPS["summary"]:"",
	Label::BackButton(), Label::CloseButton());
    Wizard::HideBackButton ();
    Wizard::HideAbortButton ();

    UI::SetFocus (`id (`snapshots_table));
    if (snapshot_items == [])
    {
	UI::ChangeWidget (`id (`show_c), `Enabled, false);
    }
    UI::ChangeWidget (`id (`configs), `Enabled, size (configs) > 1);

    any ret = nil;
    while(true) {

        ret = UI::UserInput();

        integer selected = (integer) UI::QueryWidget (`id (`snapshots_table), `CurrentItem);

        if(ret == `abort || ret == `cancel || ret == `back) {
            if(ReallyAbort()) break;
            else continue;
        }
        else if (ret == `show) {
            if (snapshots[selected,"type"]:nil == `PRE)
            {
                // popup message
                Popup::Message (_("This 'Pre' snapshot is not paired with any 'Post' one yet.
Showing differences is not possible."));
                continue;
            }
            // `POST snapshot is selected from the couple
            Snapper::selected_snapshot          = snapshots[selected]:$[];
            Snapper::selected_snapshot_index    = selected;
            break;
        }
	else if (ret == `configs) {
	    string config	= (string) UI::QueryWidget (`id (ret), `Value);
	    if (config != Snapper::current_config)
	    {
                Snapper::current_config	= config;
                update_snapshots ();
                continue;
	    }
	}
        else if (ret == `create) {
            if (CreateSnapshotPopup (pre_snapshots))
            {
                update_snapshots ();
                continue;
            }
        }
        else if (ret == `modify) {
            if (ModifySnapshotPopup (snapshots[selected]:$[]))
            {
                update_snapshots ();
                continue;
            }
        }
        else if (ret == `delete) {
            if (DeleteSnapshotPopup (snapshots[selected]:$[]))
            {
                update_snapshots ();
                continue;
            }
        }
        else if (ret == `next) {
            break;
        }
        else {
            y2error("unexpected retcode: %1", ret);
            continue;
        }
    }

    return ret;
}

/**
 * @return dialog result
 */
any ShowDialog () {

    // dialog caption
    string caption = _("Selected Snapshot Overview");

    map display_info	= UI::GetDisplayInfo ();
    boolean textmode	= display_info["TextMode"]:false;
    string previous_file= "";
    string current_file	= "";

    // map of already read files
    map<string,boolean> files	= $[];
    // currently read subtree
    list<string> subtree	= [];
    list<term> tree_items	= [];
    map open_items		= $[];

    map snapshot		= Snapper::selected_snapshot;
    integer snapshot_num	= snapshot["num"]:0;
    // map of whole tree (recursive)
    map<string, map> tree_map	= snapshot["tree_map"]:$[];
    integer previous_num	= snapshot["pre_num"]:snapshot_num;
    integer pre_index		= Snapper::id2index[previous_num]:0;
    string description		= Snapper::snapshots[pre_index,"description"]:"";
    string pre_date		= timestring ("%c", Snapper::snapshots[pre_index,"date"]:0, false);
    string date			= timestring ("%c", snapshot["date"]:0, false);
    symbol type			= snapshot["type"]:`NONE;
    list<term> combo_items	= [];
    foreach (map s, Snapper::snapshots, {
	integer id	= s["num"]:0;
	if (id != snapshot_num)
	{
	    // '%1: %2' means 'ID: description', adapt the order if necessary
	    combo_items	= add (combo_items, `item (`id (id), sformat (_("%1: %2"), id, s["description"]:"")));
	}
    });

    integer from	= snapshot_num;
    integer to	= 0; // current system
    if (snapshot["type"]:`NONE == `POST)
    {
	from	= snapshot["pre_num"]:0;
	to	= snapshot_num;
    }
    else if (snapshot["type"]:`NONE == `PRE)
    {
	to	= snapshot["post_num"]:0;
    }

    // busy popup message
    Popup::ShowFeedback ("", _("Calculating changed files..."));

    if (!haskey (snapshot, "tree_map"))
    {
	snapshot["tree_map"]	= Snapper::ReadModifiedFilesMap (from, to);
	tree_map	= snapshot["tree_map"]:$[];
    }
    // full paths of files marked as modified, mapping to changes string
    map<string,map> files_index	= $[];
    if (!haskey (snapshot, "files_index"))
    {
	snapshot["files_index"]	= Snapper::ReadModifiedFilesIndex (from, to);
	Snapper::snapshots[Snapper::selected_snapshot_index]	= snapshot;
    }
    Popup::ClearFeedback ();
    files_index	= snapshot["files_index"]:$[];

    // update the global snapshots list
    Snapper::snapshots[Snapper::selected_snapshot_index]	= snapshot;

    string snapshot_name	= tostring (snapshot_num);

    // map of all items in tree (just one level)
    map<string,boolean> selected_items	= $[];

    boolean file_was_created (string file) {
	return (substring (files_index[file,"status"]:"", 0, 1) == "+");
    }
    boolean file_was_removed (string file) {
	return (substring (files_index[file,"status"]:"", 0, 1) == "-");
    }
    // go through the map defining filesystem tree and create the widget items
    list<term> generate_tree_items (string current_path, map<string,map> current_branch) {

	list<term> ret	= [];
	foreach (string node, map branch, current_branch, {
	    string new_path	= current_path + "/" + node;
	    if (haskey (files_index, new_path))
	    {
		string icon_f	= "16x16/apps/gdu-smart-unknown.png";
		if (file_was_created (new_path))
		{
		    icon_f	= "16x16/apps/gdu-smart-healthy.png";
		}
		else if (file_was_removed (new_path))
		{
		    icon_f	= "16x16/apps/gdu-smart-failing.png";
		}
		ret = add (ret,
		    `item (`id(new_path), `icon (icon_f), node, false,
			generate_tree_items (new_path, (map<string,map>) branch))
		);
	    }
	    else
	    {
		ret = add (ret, `item (`id(new_path), node, false,
		    generate_tree_items (new_path, (map<string,map>) branch))
		);
	    }
	});
	return ret;
    }

    // helper function: show the specific modification between snapshots
    void show_file_modification (string file, integer from, integer to) {

	term content	= `VBox ();
	// busy popup message
	Popup::ShowFeedback ("", _("Calculating file modifications..."));
	map modification    = Snapper::GetFileModification (file, from, to);
	Popup::ClearFeedback ();
	list<string> status	= modification["status"]:[];
	if (contains (status, "created"))
	{
	    // label
	    content	= add (content, `Left (`Label ("New file was created.")));
	}
	else if (contains (status, "removed"))
	{
	    // label
	    content	= add (content, `Left (`Label ("File was removed.")));
	}
	else if (contains (status, "no_change"))
	{
	    // label
	    content = add (content, `Left (`Label ("File content was not changed.")));
	}
	else if (contains (status, "none"))
	{
	    // label
	    content	= add (content, `Left (`Label ("File does not exist in either snapshot.")));
	}
	else if (contains (status, "diff"))
	{
	    // label
	    content	= add (content, `Left (`Label ("File content was modified.")));
	}
	if (contains (status, "mode"))
	{
	    content	= add (content, `Left (`Label (
		// text label, %1, %2 are file modes (like '-rw-r--r--')
		sformat (_("File mode was changed from '%1' to '%2'."),
		modification["mode1"]:"", modification["mode2"]:"")
	    )));
	}
	if (contains (status, "user"))
	{
	    content	= add (content, `Left (`Label (
		// text label, %1, %2 are user names
		sformat (_("File user ownership was changed from '%1' to '%2'."),
		modification["user1"]:"", modification["user2"]:"")
	    )));
	}
	if (contains (status, "group"))
	{
	    // label
	    content	= add (content, `Left (`Label (
		// text label, %1, %2 are group names
		sformat (_("File group ownership was changed from '%1' to '%2'."),
		modification["group1"]:"", modification["group2"]:"")
	    )));
	}

	if (haskey (modification, "diff"))
	{
	    string diff	= String::EscapeTags (modification["diff"]:"");
	    list<string> l   = splitstring (diff, "\n");
	    if (!textmode)
	    {
		// colorize diff output
		l	= (list<string>) maplist (string line, l, {
		    string first = substring (line, 0, 1);
		    if (first == "+")
		    {
			line	= sformat ("<font color=blue>%1</font>", line);
		    }
		    else if (first == "-")
		    {
			line	= sformat ("<font color=red>%1</font>", line);
		    }
		    return line;
		});
	    }
	    diff	= mergestring (l, "<br>");
	    if (!textmode)
	    {
		// show fixed font in diff
		diff	= "<pre>" + diff + "</pre>";
	    }
	    content	= add (content, `RichText (`id (`diff), diff));
	}
	else
	{
	    content = add (content, `VStretch ());
	}

	// button label
        string restore_label            = _("R&estore from First");
	// button label
        string restore_label_single     = _("Restore");

	if (file_was_created (file))
	{
            restore_label       = Label::RemoveButton ();
            restore_label_single= Label::RemoveButton ();
	}

	UI::ReplaceWidget (`id (`diff_content), `HBox (`HSpacing (0.5), `VBox (
	    content,
	    `VSquash (`HBox (
		`HStretch (),
		type == `SINGLE ? `Empty () : `PushButton (`id (`restore_pre), restore_label),
		`PushButton (`id (`restore), type == `SINGLE ? restore_label_single : _("Res&tore from Second"))
	    ))
	    ), `HSpacing (0.5))
	);
	if (type != `SINGLE && file_was_removed (file))
	{
	    // file removed in 2nd snapshot cannot be restored from that snapshot
	    UI::ChangeWidget (`id (`restore), `Enabled, false);
	}
    }


    // create the term for selected file
    void set_entry_term () {
	if (current_file != "" && haskey (files_index, current_file))
	{
	    if (type == `SINGLE)
	    {
		UI::ReplaceWidget (`id (`diff_chooser), `HBox (`HSpacing (0.5), `VBox (
		    `VSpacing (0.2),
		    `RadioButtonGroup (`id(`rd), `Left (`HVSquash (`VBox (
			`Left (`RadioButton (`id(`diff_snapshot), `opt (`notify),
			    // radio button label
			    _("Show the difference between snapshot and current system"), true)),
			`VBox (
			    `Left (`RadioButton (`id (`diff_arbitrary), `opt (`notify),
				// radio button label, snapshot selection will follow
				_("Show the difference between current and selected snapshot:"), false)
			    ),
			    `HBox (
				`HSpacing (2),
				// FIXME without label, there's no shortcut!
				`Left (`ComboBox (`id (`selection_snapshots), `opt (`notify), "", combo_items))
			    )
			)
		    )))),
		    `VSpacing ()
		), `HSpacing (0.5)));
		show_file_modification (current_file, snapshot_num, 0);
		UI::ChangeWidget (`id (`selection_snapshots), `Enabled, false);
	    }
	    else
	    {
		UI::ReplaceWidget (`id (`diff_chooser), `HBox (`HSpacing (0.5), `VBox (
		    `VSpacing (0.2),
		    `RadioButtonGroup (`id(`rd), `Left (`HVSquash (`VBox (
			`Left (`RadioButton (`id(`diff_snapshot), `opt (`notify),
			    // radio button label
			    _("Show the difference between first and second snapshot"), true)),
			`Left(`RadioButton (`id (`diff_pre_current), `opt (`notify),
			    // radio button label
			    _("Show the difference between first snapshot and current system"), false)),
			`Left(`RadioButton (`id (`diff_post_current), `opt (`notify),
			    // radio button label
			    _("Show the difference between second snapshot and current system"), false))
		    )))),
		    `VSpacing ()
		), `HSpacing (0.5)));
		show_file_modification (current_file, previous_num, snapshot_num);
	    }
	}
	else
	{
	    UI::ReplaceWidget (`id (`diff_chooser), `VBox (`VStretch ()));
	    UI::ReplaceWidget (`id (`diff_content), `HBox (`HStretch ()));
	}
    }

    string tree_label	= sformat ("%1 - %2", previous_num, snapshot_num);
    // find out the path to current subvolume
    string subtree_path = Snapper::GetSnapshotPath (snapshot_num);
    subtree_path = substring (subtree_path, 0, find (subtree_path, ".snapshots/"));

    term date_widget	= `VBox (
	    `HBox (
		// label, date string will follow at the end of line
		`Label (`id (`pre_date), _("Time of taking the first snapshot:")),
		`Right (`Label (pre_date))
	    ),
	    `HBox (
		// label, date string will follow at the end of line
		`Label (`id (`post_date), _("Time of taking the second snapshot:")),
		`Right (`Label (date))
	    )
    );
    if (type == `SINGLE)
    {
	tree_label	= tostring (snapshot_num);
	date_widget	= `HBox (
		// label, date string will follow at the end of line
		`Label (`id (`date), _("Time of taking the snapshot:")),
		`Right (`Label (date))
	);
    }

    term contents = `HBox (
	`HWeight (1, `VBox (
	    `HBox (
		`HSpacing (),
		`ReplacePoint (`id (`reptree), `VBox (
		    `Left (`Label (subtree_path)),
		    `Tree (`id(`tree), tree_label, [])
		)),
		`HSpacing ()
	    ),
	    `HBox (
		`HSpacing (1.5),
		`HStretch (),
		textmode ?
		  // button label
		  `PushButton (`id (`open), `opt (`key_F6),_("&Open")):
		  `Empty (),
		`HSpacing (1.5)
	    )
	)),
	`HWeight (2, `VBox (
	    `Left (`Label (`id (`desc), description)),
	    date_widget,
	    `Frame ("", `HBox (
		`HSpacing (0.5), `VBox (
		    `VSpacing (0.5),
		    `VWeight (1, `ReplacePoint (`id (`diff_chooser), `VBox (`VStretch ()))),
		    `VWeight (4, `ReplacePoint (`id (`diff_content), `HBox (`HStretch ()))),
		    `VSpacing (0.5)
		),
		`HSpacing (0.5)
	    ))
	))
    );

    // show the dialog contents with empty tree, compute items later
    Wizard::SetContentsButtons (caption, contents,
	    type == `SINGLE ? HELPS["show_single"]:"" : HELPS["show_couple"]:"",
	    // button label
	    Label::CancelButton(), _("Restore Selected"));

    tree_items = generate_tree_items ("", tree_map);

    if (size (tree_items) > 0)
    {
	UI::ReplaceWidget (`id (`reptree), `VBox (
	    `Left (`Label (subtree_path)),
	    `Tree (`id(`tree), `opt (`notify, `immediate, `multiSelection, `recursiveSelection), tree_label, tree_items)
	));
	// no item is selected
	UI::ChangeWidget (`tree, `CurrentItem, nil);
    }

    current_file = "";

    set_entry_term ();

    if (textmode)
	UI::SetFocus (`id(`tree));

    any ret = nil;
    while(true) {

	map event       = UI::WaitForEvent ();
	ret		= (symbol) event["ID"]:nil;

	previous_file	= current_file;
	current_file = (string) UI::QueryWidget (`id(`tree),`CurrentItem);
        if (current_file == nil) current_file	= "";

	// other tree events
	if (ret == `tree)
	{
	    // seems like tree widget emits 2 SelectionChanged events
	    if (current_file != previous_file)
	    {
		set_entry_term ();
		if (textmode)
		    UI::SetFocus (`id(`tree));
	    }
	}
	else if (ret == `diff_snapshot)
	{
	    if (type == `SINGLE)
	    {
		UI::ChangeWidget (`id (`selection_snapshots), `Enabled, false);
		show_file_modification (current_file, snapshot_num, 0);
	    }
	    else
	    {
		show_file_modification (current_file, previous_num, snapshot_num);
	    }
	}
	else if (ret == `diff_arbitrary || ret == `selection_snapshots)
	{
	    UI::ChangeWidget (`id (`selection_snapshots), `Enabled, true);
	    integer selected_num	= (integer) UI::QueryWidget (`id (`selection_snapshots), `Value);
	    show_file_modification (current_file, previous_num, selected_num);
	}
	else if (ret == `diff_pre_current)
	{
	    show_file_modification (current_file, previous_num, 0);
	}
	else if (ret == `diff_post_current)
	{
	    show_file_modification (current_file, snapshot_num, 0);
	}
	else if (ret == `abort || ret == `cancel || ret == `back) {
	    break;
	}
        else if ((ret == `restore_pre || (ret == `restore && type == `SINGLE))
          && file_was_created (current_file))
        {
	    // yes/no question, %1 is file name, %2 is number
	    if (Popup::YesNo (sformat (_("Do you want to delete the file

%1

from current system?"), Snapper::GetFileFullPath (current_file))))
	    {
		Snapper::RestoreFiles (ret == `restore_pre ? previous_num : snapshot_num, [current_file]);
	    }
	    continue;
        }
	else if (ret == `restore_pre) {
	    // yes/no question, %1 is file name, %2 is number
	    if (Popup::YesNo (sformat (_("Do you want to copy the file

%1

from snapshot '%2' to current system?"), Snapper::GetFileFullPath (current_file), previous_num)))
	    {
		Snapper::RestoreFiles (previous_num, [current_file]);
	    }
	    continue;
	}
	else if (ret == `restore) {
	    // yes/no question, %1 is file name, %2 is number
	    if (Popup::YesNo (sformat (_("Do you want to copy the file

%1

from snapshot '%2' to current system?"), Snapper::GetFileFullPath (current_file), snapshot_num)))
	    {
		Snapper::RestoreFiles (snapshot_num, [current_file]);
	    }
	    continue;
	}
        else if (ret == `next) {
	    list<string> files	= (list<string>) UI::QueryWidget (`id (`tree), `SelectedItems);
	    list<string> to_restore	= [];
	    files = filter (string file, files, {
		if (haskey (files_index, file))
		{
		    to_restore	= add (to_restore, String::EscapeTags (Snapper::GetFileFullPath (file)));
		    return true;
		}
		else
		{
		    return false;
		}
	    });

	    if (to_restore == [])
	    {
		// popup message
		Popup::Message (_("No file was selected for restoring"));
		continue;
	    }
	    // popup headline
	    if (Popup::AnyQuestionRichText (_("Restoring files"),
		// popup message, %1 is snapshot number, %2 list of files
		sformat (_("<p>These files will be restored from snapshot '%1':</p>
<p>
%2
</p>
<p>Files existing in original snapshot will be copied to current system.</p>
<p>Files that did not exist in the snapshot will be deleted.</p>Are you sure?"),
		    previous_num, mergestring (to_restore, "<br>")),
		60, 20,  Label::YesButton (), Label::NoButton (), `focus_no))
	    {
		Snapper::RestoreFiles (previous_num, files);
		break;
	    }
	    continue;
        }
        else {
            y2error("unexpected retcode: %1", ret);
            continue;
        }
    }

    return ret;
}



/* EOF */
}
