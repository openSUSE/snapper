/* ------------------------------------------------------------------------------
 * Copyright (c) 2006 Novell, Inc. All Rights Reserved.
 *
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of version 2 of the GNU General Public License as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, contact Novell, Inc.
 *
 * To contact Novell about this file by physical or electronic mail, you may find
 * current contact information at www.novell.com.
 * ------------------------------------------------------------------------------
 */

/**
 * File:	include/snapper/dialogs.ycp
 * Package:	Configuration of snapper
 * Summary:	Dialogs definitions
 * Authors:	Jiri Suchomel <jsuchome@suse.cz>
 *
 * $Id$
 */

{

textdomain "snapper";

import "Confirm";
import "FileUtils";
import "Label";
import "Popup";
import "Wizard";
import "Snapper";

include "snapper/helps.ycp";

boolean ReallyAbort() {
    return Popup::ReallyAbort(true);
}

/**
 * Read settings dialog
 * @return `abort if aborted and `next otherwise
 */
symbol ReadDialog() {

    if (! Confirm::MustBeRoot ())
	return `abort;

    Wizard::RestoreHelp(HELPS["read"]:"");
    boolean ret = Snapper::Read();
    return ret ? `next : `abort;
}

/**
 * Summary dialog
 * @return dialog result
 */
any SummaryDialog() {

    /* summary dialog caption */
    string caption = _("Snapshots");

    list<map> snapshots	= Snapper::snapshots;
    integer i	= -1;

    list snapshot_items	= [];

    foreach (map s, snapshots, {
	i	= i + 1;

	integer num	= s["num"]:0;
	string date	= "";
	if (num != 0)
	    date = timestring ("%c", s["date"]:0, false);

	if (s["type"]:`none == `SINGLE)
	{
	    snapshot_items	= add (snapshot_items,
		`item (`id (i), num, _("Single"), date, "", s["description"]:""));
	}
	else if (s["type"]:`none == `POST)
	{
	    integer pre		= s["pre_num"]:0; // pre canot be 0
	    integer index	= Snapper::id2index[pre]:-1;
	    if (pre == 0 || index == -1)
	    {
		y2warning ("something wrong - pre:%1, index:%2", pre, index);
		continue;
	    }
	    string desc	= Snapper::snapshots[index,"description"]:"";
	    string pre_date = timestring ("%c", Snapper::snapshots[index,"date"]:0, false);
	    snapshot_items	= add (snapshot_items,
		`item (`id (i), sformat ("%1 - %2", pre, num), _("Pre & Post"), pre_date, date, desc));
	}
	else
	{
	    y2milestone ("skipping pre snapshot: %1", num);
	}
    });

    term contents = `VBox (
	`Table (`id (`snapshots_table), `opt(`notify, `keepSorting), `header (
		// table header
		_("ID"), _("Type"), _("Start Date"), _("End Date"), _("Description")),
		snapshot_items
	),
	`HBox (
	    `PushButton (`id (`show_c), `opt (`default), _("Show Changes")),
	    `HStretch ()
	)
    );

    Wizard::SetContentsButtons(caption, contents, HELPS["summary"]:"",
	Label::BackButton(), Label::CloseButton());
    Wizard::HideBackButton ();
    Wizard::HideAbortButton ();

    UI::SetFocus (`id (`snapshots_table));
    if (snapshot_items == [])
    {
	UI::ChangeWidget (`id (`show_c), `Enabled, false);
    }

    any ret = nil;
    while(true) {

	ret = UI::UserInput();

	integer selected = 0;

	if (ret == `show_c || ret == `snapshots_table) {
	    selected = (integer) UI::QueryWidget (`id (`snapshots_table), `CurrentItem);
	    ret = `show;
	}

	if(ret == `abort || ret == `cancel || ret == `back) {
	    if(ReallyAbort()) break;
	    else continue;
	}
        else if (ret == `show) {
	    // `POST snapshot is selected from the couple
	    Snapper::selected_snapshot	= snapshots[selected]:$[];
	    Snapper::selected_snapshot_index	= selected;
            break;
        }
        else if(ret == `next) {
	    // TODO check if something needs to be written (description)
            break;
        }
        else {
            y2error("unexpected retcode: %1", ret);
            continue;
        }
    }

    return ret;
}

/**
 * @return dialog result
 */
any ShowDialog () {

    // dialog caption
    string caption = _("Selected Snapshot Overview");

    map display_info	= UI::GetDisplayInfo ();
    boolean textmode	= display_info["TextMode"]:false;
    string previous_file= "";
    string current_file	= "";

    // map of already read files
    map<string,boolean> files	= $[];
    // currently read subtree
    list<string> subtree	= [];
    list<term> tree_items	= [];
    map open_items		= $[];

    map snapshot		= Snapper::selected_snapshot;
    integer snapshot_num	= snapshot["num"]:0;
    // map of whole tree (recursive)
    map<string, map> tree_map	= snapshot["tree_map"]:$[];
    integer previous_num	= snapshot["pre_num"]:snapshot_num;
    integer pre_index		= Snapper::id2index[previous_num]:0;
    string description		= Snapper::snapshots[pre_index,"description"]:"";
    string pre_date		= timestring ("%c", Snapper::snapshots[pre_index,"date"]:0, false);
    string date			= timestring ("%c", snapshot["date"]:0, false);
    symbol type			= snapshot["type"]:`NONE;
    list<term> combo_items	= [];
    foreach (map s, Snapper::snapshots, {
	integer id	= s["num"]:0;
	if (id != snapshot_num)
	{
	    // '%1: %2' means 'ID: description', adapt the order if necessary
	    combo_items	= add (combo_items, `item (`id (id), sformat (_("%1: %2"), id, s["description"]:"")));
	}
    });

    integer from	= snapshot_num;
    integer to	= 0; // current system
    if (snapshot["type"]:`NONE == `POST)
    {
	from	= snapshot["pre_num"]:0;
	to	= snapshot_num;
    }
    else if (snapshot["type"]:`NONE == `PRE)
    {
	to	= snapshot["post_num"]:0;
    }

    // busy popup message
    Popup::ShowFeedback ("", _("Calculating changed files..."));

    if (!haskey (snapshot, "tree_map"))
    {
	snapshot["tree_map"]	= Snapper::ReadModifiedFilesMap (from, to);
	Popup::ClearFeedback ();
	tree_map	= snapshot["tree_map"]:$[];
    }
    // full paths of files marked as modified, mapping to changes string
    map<string,string> files_index	= $[];
    if (!haskey (snapshot, "files_index"))
    {
	snapshot["files_index"]	= Snapper::ReadModifiedFilesIndex (from, to);
	Snapper::snapshots[Snapper::selected_snapshot_index]	= snapshot;
    }
    files_index	= snapshot["files_index"]:$[];

    // update the global snapshots list
    Snapper::snapshots[Snapper::selected_snapshot_index]	= snapshot;

    string snapshot_name	= tostring (snapshot_num);

    // map of all items in tree (just one level)
    map<string,boolean> selected_items	= $[];

    boolean file_was_created (string file) {
	return (substring (files_index[file]:"", 0, 1) == "+");
    }
    boolean file_was_removed (string file) {
	return (substring (files_index[file]:"", 0, 1) == "-");
    }

    // go through the map defining filesystem tree and create the widget items
    list<term> generate_tree_items (string current_path, map<string,map> current_branch) {

	list<term> ret	= [];
	foreach (string node, map branch, current_branch, {
	    string new_path	= current_path + "/" + node;
	    if (haskey (files_index, new_path))
	    {
		string icon_f	= "16x16/apps/gdu-smart-unknown.png";
		if (file_was_created (new_path))
		{
		    icon_f	= "16x16/apps/gdu-smart-healthy.png";
		}
		else if (file_was_removed (new_path))
		{
		    icon_f	= "16x16/apps/gdu-smart-failing.png";
		}
		ret = add (ret,
		    `item (`id(new_path), `icon (icon_f), node, false,
			generate_tree_items (new_path, (map<string,map>) branch))
		);
	    }
	    else
	    {
		ret = add (ret, `item (`id(new_path), node, false,
		    generate_tree_items (new_path, (map<string,map>) branch))
		);
	    }
	});
	return ret;
    }

    // helper function: show the specific modification between snapshots
    void show_file_modification (string file, integer from, integer to) {

	term content	= `VBox ();
	// busy popup message
	Popup::ShowFeedback ("", _("Calculating file modifications..."));
	map modification    = Snapper::GetFileModification (file, from, to);
	Popup::ClearFeedback ();
	list<string> status	= modification["status"]:[];
	if (contains (status, "created"))
	{
	    // label
	    content	= add (content, `Left (`Label ("New file was created.")));
	}
	else if (contains (status, "removed"))
	{
	    // label
	    content	= add (content, `Left (`Label ("File was removed.")));
	}
	else if (contains (status, "no_change"))
	{
	    // label
	    content = add (content, `Left (`Label ("File content was not changed.")));
	}
	else if (contains (status, "none"))
	{
	    // label
	    content	= add (content, `Left (`Label ("File does not exist in either snapshot.")));
	}
	else if (contains (status, "diff"))
	{
	    // label
	    content	= add (content, `Left (`Label ("File content was modified.")));
	}
	if (contains (status, "mode"))
	{
	    content	= add (content, `Left (`Label (
		// text label, %1, %2 are file modes (like '-rw-r--r--')
		sformat (_("File mode was changed from '%1' to '%2'."),
		modification["mode1"]:"", modification["mode2"]:"")
	    )));
	}
	if (contains (status, "user"))
	{
	    content	= add (content, `Left (`Label (
		// text label, %1, %2 are user names
		sformat (_("File user ownership was changed from '%1' to '%2'."),
		modification["user1"]:"", modification["user2"]:"")
	    )));
	}
	if (contains (status, "group"))
	{
	    // label
	    content	= add (content, `Left (`Label (
		// text label, %1, %2 are group names
		sformat (_("File group ownership was changed from '%1' to '%2'."),
		modification["group1"]:"", modification["group2"]:"")
	    )));
	}

	if (haskey (modification, "diff"))
	{
	    string diff	= modification["diff"]:"";
	    diff	= mergestring (splitstring (diff, "\n"), "<br>");
	    content	= add (content, `RichText (`id (`diff), diff));
	}
	else
	{
	    content = add (content, `VStretch ());
	}

	UI::ReplaceWidget (`id (`diff_content), `HBox (`HSpacing (0.5), `VBox (
	    content,
	    `VSquash (`HBox (
		`HStretch (),
		// button label
		type == `SINGLE ? `Empty () : `PushButton (`id (`restore_pre), _("R&estore From First")),
		// button label
		`PushButton (`id (`restore), type == `SINGLE ? _("Restore") : _("Res&tore From Second"))
	    ))
	    ), `HSpacing (0.5))
	);
	if (file_was_created (file))
	{
	    // file created after taking first snapshot cannot be restored from that snapshot
	    if (type == `SINGLE)
	    {
		UI::ChangeWidget (`id (`restore), `Enabled, false);
	    }
	    else
	    {
		UI::ChangeWidget (`id (`restore_pre), `Enabled, false);
	    }
	}
	else if (type != `SINGLE && file_was_removed (file))
	{
	    // file removed in 2nd snapshot cannot be restored from that snapshot
	    UI::ChangeWidget (`id (`restore), `Enabled, false);
	}
    }


    // create the term for selected file
    void set_entry_term () {
	if (current_file != "" && haskey (files_index, current_file))
	{
	    if (type == `SINGLE)
	    {
		UI::ReplaceWidget (`id (`diff_chooser), `HBox (`HSpacing (0.5), `VBox (
		    `VSpacing (0.2),
		    `RadioButtonGroup (`id(`rd), `Left (`HVSquash (`VBox (
			`Left (`RadioButton (`id(`diff_snapshot), `opt (`notify),
			    // radio button label
			    _("Show the difference between snapshot and current system"), true)),
			`VBox (
			    `Left (`RadioButton (`id (`diff_arbitrary), `opt (`notify),
				// radio button label, snapshot selection will follow
				_("Show the difference between current and selected snapshot:"), false)
			    ),
			    `HBox (
				`HSpacing (2),
				// FIXME without label, there's no shortcut!
				`Left (`ComboBox (`id (`selection_snapshots), `opt (`notify), "", combo_items))
			    )
			)
		    )))),
		    `VSpacing ()
		), `HSpacing (0.5)));
		show_file_modification (current_file, snapshot_num, 0);
		UI::ChangeWidget (`id (`selection_snapshots), `Enabled, false);
	    }
	    else
	    {
		UI::ReplaceWidget (`id (`diff_chooser), `HBox (`HSpacing (0.5), `VBox (
		    `VSpacing (0.2),
		    `RadioButtonGroup (`id(`rd), `Left (`HVSquash (`VBox (
			`Left (`RadioButton (`id(`diff_snapshot), `opt (`notify),
			    // radio button label
			    _("Show the difference between first and second snapshot"), true)),
			`Left(`RadioButton (`id (`diff_pre_current), `opt (`notify),
			    // radio button label
			    _("Show the difference between first snapshot and current system"), false)),
			`Left(`RadioButton (`id (`diff_post_current), `opt (`notify),
			    // radio button label
			    _("Show the difference between second snapshot and current system"), false))
		    )))),
		    `VSpacing ()
		), `HSpacing (0.5)));
		show_file_modification (current_file, previous_num, snapshot_num);
	    }
	}
	else
	{
	    UI::ReplaceWidget (`id (`diff_chooser), `VBox (`VStretch ()));
	    UI::ReplaceWidget (`id (`diff_content), `HBox (`HStretch ()));
	}
    }

    string tree_label	= sformat ("%1 - %2", previous_num, snapshot_num);
    term date_widget	= `VBox (
	    `HBox (
		// label, date string will follow at the end of line
		`Label (`id (`pre_date), _("Time of taking the first snapshot:")),
		`Right (`Label (pre_date))
	    ),
	    `HBox (
		// label, date string will follow at the end of line
		`Label (`id (`post_date), _("Time of taking the second snapshot:")),
		`Right (`Label (date))
	    )
    );
    if (type == `SINGLE)
    {
	tree_label	= tostring (snapshot_num);
	date_widget	= `HBox (
		// label, date string will follow at the end of line
		`Label (`id (`date), _("Time of taking the snapshot:")),
		`Right (`Label (date))
	);
    }

    term contents = `HBox (
	`HWeight (1, `HBox (`VSpacing (20), `VBox (`HSpacing(70),
	    `HBox (
		`HSpacing (),
		`ReplacePoint (`id (`reptree),
		    `Tree (`id(`tree), tree_label, [])
		),
		`HSpacing ()
	    ),
	    `HBox (
		`HSpacing (1.5),
		`HStretch (),
		textmode ?
		  // button label
		  `PushButton (`id (`open), `opt (`key_F6),_("&Open")):
		  `Empty (),
		`HSpacing (1.5)
	    )
	))),
	`HWeight (2, `VBox (
	    `Left (`Label (`id (`desc), description)),
	    date_widget,
	    `Frame ("", `HBox (
		`HSpacing (0.5), `VBox (
		    `VSpacing (0.5),
		    `VWeight (1, `ReplacePoint (`id (`diff_chooser), `VBox (`VStretch ()))),
		    `VWeight (4, `ReplacePoint (`id (`diff_content), `HBox (`HStretch ()))),
		    `VSpacing (0.5)
		),
		`HSpacing (0.5)
	    ))
	))
    );

    // show the dialog contents with empty tree, compute items later
    Wizard::SetContentsButtons (caption, contents,
	    type == `SINGLE ? HELPS["show_single"]:"" : HELPS["show_couple"]:"",
	    // button label
	    Label::CancelButton(), _("Restore Selected"));

    tree_items = generate_tree_items ("", tree_map);

    if (size (tree_items) > 0)
    {
	UI::ReplaceWidget (`id (`reptree),
	    `Tree (`id(`tree), `opt (`notify, `immediate, `multiSelection), tree_label, tree_items)
	);
	// no item is selected
	UI::ChangeWidget (`tree, `CurrentItem, nil);
    }

    current_file = "";

    set_entry_term ();

    if (textmode)
	UI::SetFocus (`id(`tree));

    any ret = nil;
    while(true) {

	map event       = UI::WaitForEvent ();
	ret		= (symbol) event["ID"]:nil;

	previous_file	= current_file;
	current_file = (string) UI::QueryWidget (`id(`tree),`CurrentItem);
        if (current_file == nil) current_file	= "";

	// tree checkbox clicked
	if (ret == `tree && event["EventReason"]:"" == "ValueChanged")
	{
	    // non-tracked file should be directory
	    if (current_file != "" &&
		(! haskey (files_index, current_file) || FileUtils::IsDirectory (current_file) == true))
	    {
		void select_items (map<string,map> current_map, string prefix) {
		    selected_items[prefix]	= ! selected_items[prefix]:false;
		    foreach (string key, map submap, current_map, {
			string new_path			= prefix + "/" + key;
			if (submap != $[])
			{
			    select_items ((map<string,map>) submap, new_path);
			}
			else
			{
			    selected_items[new_path]	= ! selected_items[new_path]:false;
			}
		    });
		}
		void update_selection (map<string,map> current_map, list<string> path_list)
		{
		    string first	= path_list[0]:"";
		    if (size (path_list) == 0)
		    {
			select_items (current_map, current_file);
		    }
		    else if (haskey (current_map, first))
		    {
			update_selection ((map<string,map>)current_map[first]:$[],
					  (list<string>) remove (path_list, 0)
			);
		    }
		}
		list<string> path_l	= splitstring (current_file, "/");
		if (path_l[0]:"" == "")
		    path_l		= remove (path_l, 0);

		update_selection (tree_map, path_l);

		list<string> selection	= [];
		foreach (string key, boolean val, selected_items, {
		    if (val)
			selection	= add (selection, key);
		});
		UI::ChangeWidget (`tree, `SelectedItems, selection);
	    }

	}
	// other tree events
	else if (ret == `tree)
	{
	    // seems like tree widget emits 2 SelectionChanged events
	    if (current_file != previous_file)
	    {
		set_entry_term ();
		if (textmode)
		    UI::SetFocus (`id(`tree));
	    }
	}
	else if (ret == `diff_snapshot)
	{
	    if (type == `SINGLE)
	    {
		UI::ChangeWidget (`id (`selection_snapshots), `Enabled, false);
		show_file_modification (current_file, snapshot_num, 0);
	    }
	    else
	    {
		show_file_modification (current_file, previous_num, snapshot_num);
	    }
	}
	else if (ret == `diff_arbitrary || ret == `selection_snapshots)
	{
	    UI::ChangeWidget (`id (`selection_snapshots), `Enabled, true);
	    integer selected_num	= (integer) UI::QueryWidget (`id (`selection_snapshots), `Value);
	    show_file_modification (current_file, previous_num, selected_num);
	}
	else if (ret == `diff_pre_current)
	{
	    show_file_modification (current_file, previous_num, 0);
	}
	else if (ret == `diff_post_current)
	{
	    show_file_modification (current_file, snapshot_num, 0);
	}
	else if (ret == `abort || ret == `cancel || ret == `back) {
	    break;
	}
	else if (ret == `restore_pre) {
	    // yes/no question, %1 is file name, %2 is number
	    if (Popup::YesNo (sformat ("Do you want to copy the file

%1

from snapshot '%2' to current system?", current_file, previous_num)))
	    {
		Snapper::RestoreFiles (previous_num, [current_file]);
	    }
	    continue;
	}
	else if (ret == `restore) {
	    // yes/no question, %1 is file name, %2 is number
	    if (Popup::YesNo (sformat ("Do you want to copy the file

%1

from snapshot '%2' to current system?", current_file, snapshot_num)))
	    {
		Snapper::RestoreFiles (snapshot_num, [current_file]);
	    }
	    continue;
	}
        else if (ret == `next) {
	    list<string> files	= (list<string>) UI::QueryWidget (`id (`tree), `SelectedItems);
	    files = filter (string file, files, {
		return haskey (files_index, file);
	    });

	    if (files == [])
	    {
		// popup message
		Popup::Message (_("No file was selected for restoring"));
		continue;
	    }
	    // FIXME restore from PRE or POST? (PRE by default)
	    // popup headline
	    if (Popup::AnyQuestionRichText (_("Restoring files"),
		// popup message, %1 is snapshot number, %2 list of files
		sformat (_("These files will be copied from snapshot '%1' to current system: <p>%2</p>Are you sure?"),
		    previous_num, mergestring (files, "<br>")),
		60, 20,  Label::YesButton (), Label::NoButton (), `focus_no))
	    {
		Snapper::RestoreFiles (previous_num, files);
		break;
	    }
	    continue;
        }
        else {
            y2error("unexpected retcode: %1", ret);
            continue;
        }
    }

    return ret;
}



/* EOF */
}
